import MeetupDetail from "../../components/meetups/MeetupDetail";
import { MongoClient, ObjectId } from "mongodb";
import Head from "next/head";

const DB_URL = process.env.REACT_APP_DB_URL;

const MeetupDetails = (props) => {
  const { image, title, address, description } = props.meetupDetails;
  return (
    <>
      <Head>
        <title>{title}</title>
        <meta name="description" content={description} />
      </Head>
      <MeetupDetail
        image={image}
        title={title}
        address={address}
        description={description}
      />
    </>
  );
};

export async function getStaticPaths() {
  const client = await MongoClient.connect(DB_URL);
  const db = client.db();

  const meetupCollection = db.collection("meetups");
  // fetch only all the ids of meetups
  const meetups = await meetupCollection.find({}, { _id: 1 }).toArray();
  client.close();

  return {
    // if we have all the supported paths, use fallback as false. Else, set as true.
    // when fallback is false, it will show a 404 page generated by next is the path doesnt exist
    // if it is true/'blocking', if the path doesnt exist, next js will try to generate the page and then cache it accordingly
    // this is useful because getStaticPaths() only run one during build time and hence, if there are more meetups, the data would be outdated
    // if we do fallback: false, should a user add more meetups and we try to click on it, we'll run into 404 since the data at build is outdated.
    // however, if we set it to true/'blocking instead, next js will try to generate the page and then cache it.
    // true vs "blocking" :
    // true: immediately return an empty page, then get the dynamically generated content once its done; hence we need to handle the case where the page doesnt have the data yet
    // "blocking": user will not see any page until the page is finished pre-generated and served (hence we dont need to handle any case)
    fallback: "blocking",
    paths: meetups.map((meetup) => ({
      params: { meetupId: meetup._id.toString() },
    })),
  };
}

export async function getStaticProps(context) {
  // .meetupId because the folder is called [meetupId]
  const meetupId = context.params.meetupId;

  const client = await MongoClient.connect(DB_URL);
  const db = client.db();

  const meetupCollection = db.collection("meetups");
  // fetch only all the ids of meetups
  const selectedMeetup = await meetupCollection.findOne({
    _id: new ObjectId(meetupId),
  });
  client.close();
  // fetch data for a single meetup using the meetupId....

  return {
    props: {
      meetupDetails: { ...selectedMeetup, _id: selectedMeetup._id.toString() },
    },
    revalidate: 10,
  };
}

export default MeetupDetails;
